"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

require("core-js/modules/es.reflect.construct.js");

require("core-js/modules/es.object.create.js");

require("core-js/modules/es.object.define-property.js");

require("core-js/modules/es.array.is-array.js");

require("core-js/modules/es.symbol.js");

require("core-js/modules/es.symbol.description.js");

require("core-js/modules/es.symbol.iterator.js");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.string.iterator.js");

require("core-js/modules/web.dom-collections.iterator.js");

require("core-js/modules/es.array.from.js");

require("core-js/modules/es.array.slice.js");

require("core-js/modules/es.function.name.js");

require("core-js/modules/es.weak-map.js");

require("core-js/modules/es.object.get-own-property-descriptor.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

require("core-js/modules/es.regexp.exec.js");

require("core-js/modules/es.string.replace.js");

require("core-js/modules/es.array.for-each.js");

require("core-js/modules/web.dom-collections.for-each.js");

require("core-js/modules/es.date.to-string.js");

require("core-js/modules/es.object.to-string.js");

require("core-js/modules/es.regexp.to-string.js");

require("core-js/modules/es.array.concat.js");

require("core-js/modules/es.array.find.js");

require("core-js/modules/es.object.set-prototype-of.js");

require("core-js/modules/es.object.get-prototype-of.js");

var _child_process = require("child_process");

var _fs = require("fs");

var _os = require("os");

var path = _interopRequireWildcard(require("path"));

var _events = _interopRequireDefault(require("events"));

var _types = require("./types");

var _project_workspace = _interopRequireDefault(require("./project_workspace"));

var _Process = require("./Process");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

// This class represents the running process, and
// passes out events when it understands what data is being
// pass sent out of the process
var Runner = /*#__PURE__*/function (_EventEmitter) {
  _inherits(Runner, _EventEmitter);

  var _super = _createSuper(Runner);

  function Runner(workspace, options) {
    var _this;

    _classCallCheck(this, Runner);

    _this = _super.call(this);
    _this._createProcess = options && options.createProcess || _Process.createProcess;
    _this.options = options || {};
    _this.workspace = workspace;
    _this.outputPath = path.join((0, _os.tmpdir)(), "jest_runner_".concat(_this.workspace.outputFileSuffix || '', ".json"));
    _this.prevMessageTypes = [];
    _this._exited = false;
    return _this;
  }

  _createClass(Runner, [{
    key: "_getArgs",
    value: function _getArgs() {
      if (this.options.args && this.options.args.replace) {
        return this.options.args.args;
      } // Handle the arg change on v18


      var belowEighteen = this.workspace.localJestMajorVersion < 18;
      var outputArg = belowEighteen ? '--jsonOutputFile' : '--outputFile';
      var args = ['--testLocationInResults', '--json', '--useStderr', outputArg, this.outputPath];

      if (this.watchMode) {
        args.push(this.watchAll ? '--watchAll' : '--watch');
      }

      if (this.options.testNamePattern) {
        args.push('--testNamePattern', this.options.testNamePattern);
      }

      if (this.options.testFileNamePattern) {
        args.push(this.options.testFileNamePattern);
      }

      if (this.workspace.collectCoverage === true) {
        args.push('--coverage');
      }

      if (this.workspace.collectCoverage === false) {
        args.push('--no-coverage');
      }

      if (this.options.noColor === true) {
        args.push('--no-color');
      }

      if (this.options.reporters) {
        this.options.reporters.forEach(function (reporter) {
          args.push('--reporters', reporter);
        });
      }

      if (this.options.args) {
        args.push.apply(args, _toConsumableArray(this.options.args.args));
      }

      return args;
    }
  }, {
    key: "start",
    value: function start() {
      var _this2 = this;

      var watchMode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var watchAll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (this.debugprocess) {
        return;
      }

      this.watchMode = watchMode;
      this.watchAll = watchAll;

      var args = this._getArgs();

      this.debugprocess = this._createProcess(this.workspace, args);
      this.debugprocess.stdout.on('data', function (data) {
        _this2._parseOutput(data, false);
      });
      this.debugprocess.stderr.on('data', function (data) {
        // jest 23 could send test results message to stderr
        // see https://github.com/facebook/jest/pull/4858
        _this2._parseOutput(data, true);
      });
      this.debugprocess.on('exit', function (code, signal) {
        _this2._exited = true; // this is mainly for backward compatibility, should be deprecated soon

        _this2.emit('debuggerProcessExit');

        _this2.emit('processExit', code, signal);

        _this2.prevMessageTypes.length = 0;
      });
      this.debugprocess.on('error', function (error) {
        _this2.emit('terminalError', "Process failed: ".concat(error.message));

        _this2.prevMessageTypes.length = 0;
      });
      this.debugprocess.on('close', function (code, signal) {
        // this is mainly for backward compatibility, should be deprecated soon
        _this2.emit('debuggerProcessExit');

        _this2.emit('processClose', code, signal);

        _this2.prevMessageTypes.length = 0;
      });
    }
    /**
     * parse the stdin/out stream buffer for recognized messages.
     *
     * note: if these messages coming in in separate chucks, we might not be able to
     * resolve it properly. While there haven't been much evidence of such scenario,
     * it's worth to note that it could and we might need to buffer them in that case.
     * see https://github.com/jest-community/jest-editor-support/pull/9#pullrequestreview-231888752
     *
     * @param {Buffer} data
     * @param {boolean} isStdErr
     * @returns {MessageType}
     * @memberof Runner
     */

  }, {
    key: "_parseOutput",
    value: function _parseOutput(data, isStdErr) {
      var _this3 = this;

      var msgType = this.findMessageType(data);

      switch (msgType) {
        case _types.messageTypes.testResults:
          this.emit('executableStdErr', data, {
            type: msgType
          });
          (0, _fs.readFile)(this.outputPath, 'utf8', function (err, _data) {
            if (err) {
              var message = "JSON report not found at ".concat(_this3.outputPath);

              _this3.emit('terminalError', message);
            } else {
              var noTestsFound = _this3.doResultsFollowNoTestsFoundMessage();

              _this3.emit('executableJSON', JSON.parse(_data), {
                noTestsFound: noTestsFound
              });
            }
          });
          this.prevMessageTypes.length = 0;
          break;

        case _types.messageTypes.watchUsage:
        case _types.messageTypes.noTests:
          this.prevMessageTypes.push(msgType);
          this.emit('executableStdErr', data, {
            type: msgType
          });
          break;

        default:
          // no special action needed, just report the output by its source
          if (isStdErr) {
            this.emit('executableStdErr', data, {
              type: msgType
            });
          } else {
            // remove clear screen escape sequence
            this.emit('executableOutput', data.toString().replace('[2J[H', ''));
          }

          this.prevMessageTypes.length = 0;
          break;
      }

      return msgType;
    }
  }, {
    key: "runJestWithUpdateForSnapshots",
    value: function runJestWithUpdateForSnapshots(completion, args) {
      var defaultArgs = ['--updateSnapshot'];

      var updateProcess = this._createProcess(this.workspace, [].concat(defaultArgs, _toConsumableArray(args || [])));

      updateProcess.on('close', function () {
        completion();
      });
    }
  }, {
    key: "closeProcess",
    value: function closeProcess() {
      if (!this.debugprocess || this._exited) {
        // eslint-disable-next-line no-console
        console.log("process has not started or already exited");
        return;
      }

      if (process.platform === 'win32') {
        // Windows doesn't exit the process when it should.
        (0, _child_process.spawn)('taskkill', ['/pid', "".concat(this.debugprocess.pid), '/T', '/F']);
      } else {
        try {
          // kill all process with the same PGID, i.e.
          // as a detached process, it is the same as the PID of the leader process.
          process.kill(-this.debugprocess.pid);
        } catch (e) {
          // if anything goes wrong, fallback to the old benavior
          // knowing this could leave orphan process...
          // eslint-disable-next-line no-console
          console.warn("failed to kill process group, this could leave some orphan process whose ppid=".concat(this.debugprocess.pid, ". error="), e);
          this.debugprocess.kill();
        }
      }

      delete this.debugprocess;
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "findMessageType",
    value: function findMessageType(buf) {
      var noTestRegex = /No tests found related to files changed since ((last commit)|("[a-z0-9]+"))./;
      var watchUsageRegex = /^\s*Watch Usage\b/;
      var testResultsRegex = /Test results written to/;
      var checks = [{
        regex: testResultsRegex,
        messageType: _types.messageTypes.testResults
      }, {
        regex: noTestRegex,
        messageType: _types.messageTypes.noTests
      }, {
        regex: watchUsageRegex,
        messageType: _types.messageTypes.watchUsage
      }];
      var str = buf.toString('utf8');
      var match = checks.find(function (_ref) {
        var regex = _ref.regex;
        return regex.test(str);
      });
      return match ? match.messageType : _types.messageTypes.unknown;
    }
  }, {
    key: "doResultsFollowNoTestsFoundMessage",
    value: function doResultsFollowNoTestsFoundMessage() {
      if (this.prevMessageTypes.length === 1) {
        return this.prevMessageTypes[0] === _types.messageTypes.noTests;
      }

      if (this.prevMessageTypes.length === 2) {
        return this.prevMessageTypes[0] === _types.messageTypes.noTests && this.prevMessageTypes[1] === _types.messageTypes.watchUsage;
      }

      return false;
    }
  }]);

  return Runner;
}(_events["default"]);

exports["default"] = Runner;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9SdW5uZXIuanMiXSwibmFtZXMiOlsiUnVubmVyIiwid29ya3NwYWNlIiwib3B0aW9ucyIsIl9jcmVhdGVQcm9jZXNzIiwiY3JlYXRlUHJvY2VzcyIsIm91dHB1dFBhdGgiLCJwYXRoIiwiam9pbiIsIm91dHB1dEZpbGVTdWZmaXgiLCJwcmV2TWVzc2FnZVR5cGVzIiwiX2V4aXRlZCIsImFyZ3MiLCJyZXBsYWNlIiwiYmVsb3dFaWdodGVlbiIsImxvY2FsSmVzdE1ham9yVmVyc2lvbiIsIm91dHB1dEFyZyIsIndhdGNoTW9kZSIsInB1c2giLCJ3YXRjaEFsbCIsInRlc3ROYW1lUGF0dGVybiIsInRlc3RGaWxlTmFtZVBhdHRlcm4iLCJjb2xsZWN0Q292ZXJhZ2UiLCJub0NvbG9yIiwicmVwb3J0ZXJzIiwiZm9yRWFjaCIsInJlcG9ydGVyIiwiZGVidWdwcm9jZXNzIiwiX2dldEFyZ3MiLCJzdGRvdXQiLCJvbiIsImRhdGEiLCJfcGFyc2VPdXRwdXQiLCJzdGRlcnIiLCJjb2RlIiwic2lnbmFsIiwiZW1pdCIsImxlbmd0aCIsImVycm9yIiwibWVzc2FnZSIsImlzU3RkRXJyIiwibXNnVHlwZSIsImZpbmRNZXNzYWdlVHlwZSIsIm1lc3NhZ2VUeXBlcyIsInRlc3RSZXN1bHRzIiwidHlwZSIsImVyciIsIl9kYXRhIiwibm9UZXN0c0ZvdW5kIiwiZG9SZXN1bHRzRm9sbG93Tm9UZXN0c0ZvdW5kTWVzc2FnZSIsIkpTT04iLCJwYXJzZSIsIndhdGNoVXNhZ2UiLCJub1Rlc3RzIiwidG9TdHJpbmciLCJjb21wbGV0aW9uIiwiZGVmYXVsdEFyZ3MiLCJ1cGRhdGVQcm9jZXNzIiwiY29uc29sZSIsImxvZyIsInByb2Nlc3MiLCJwbGF0Zm9ybSIsInBpZCIsImtpbGwiLCJlIiwid2FybiIsImJ1ZiIsIm5vVGVzdFJlZ2V4Iiwid2F0Y2hVc2FnZVJlZ2V4IiwidGVzdFJlc3VsdHNSZWdleCIsImNoZWNrcyIsInJlZ2V4IiwibWVzc2FnZVR5cGUiLCJzdHIi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LGdCQUFSO0FBQTBCRyxRQUFBQSxXQUFXLEVBQUU3QixvQkFBYUM7QUFBcEQsT0FEYSxFQUViO0FBQUMyQixRQUFBQSxLQUFLLEVBQUVKLFdBQVI7QUFBcUJLLFFBQUFBLFdBQVcsRUFBRTdCLG9CQUFhVTtBQUEvQyxPQUZhLEVBR2I7QUFBQ2tCLFFBQUFBLEtBQUssRUFBRUgsZUFBUjtBQUF5QkksUUFBQUEsV0FBVyxFQUFFN0Isb0JBQWFTO0FBQW5ELE9BSGEsQ0FBZjtBQU1BLFVBQU1xQixHQUFHLEdBQUdQLEdBQUcsQ0FBQ1osUUFBSixDQUFhLE1BQWIsQ0FBWjtBQUNBLFVBQU1vQixLQUFLLEdBQUdKLE1BQU0sQ0FBQ0ssSUFBUCxDQUFZO0FBQUEsWUFBRUosS0FBRixRQUFFQSxLQUFGO0FBQUEsZUFBYUEsS0FBSyxDQUFDSyxJQUFOLENBQVdILEdBQVgsQ0FBYjtBQUFBLE9BQVosQ0FBZDtBQUNBLGFBQU9DLEtBQUssR0FBR0EsS0FBSyxDQUFDRixXQUFULEdBQXVCN0Isb0JBQWFrQyxPQUFoRDtBQUNEOzs7V0FFRCw4Q0FBcUM7QUFDbkMsVUFBSSxLQUFLbkUsZ0JBQUwsQ0FBc0IyQixNQUF0QixLQUFpQyxDQUFyQyxFQUF3QztBQUN0QyxlQUFPLEtBQUszQixnQkFBTCxDQUFzQixDQUF0QixNQUE2QmlDLG9CQUFhVSxPQUFqRDtBQUNEOztBQUVELFVBQUksS0FBSzNDLGdCQUFMLENBQXNCMkIsTUFBdEIsS0FBaUMsQ0FBckMsRUFBd0M7QUFDdEMsZUFBTyxLQUFLM0IsZ0JBQUwsQ0FBc0IsQ0FBdEIsTUFBNkJpQyxvQkFBYVUsT0FBMUMsSUFBcUQsS0FBSzNDLGdCQUFMLENBQXNCLENBQXRCLE1BQTZCaUMsb0JBQWFTLFVBQXRHO0FBQ0Q7O0FBRUQsYUFBTyxLQUFQO0FBQ0Q7Ozs7RUF4T2lDMEIsa0IiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuaW1wb3J0IHtDaGlsZFByb2Nlc3MsIHNwYXdufSBmcm9tICdjaGlsZF9wcm9jZXNzJztcbmltcG9ydCB7cmVhZEZpbGV9IGZyb20gJ2ZzJztcbmltcG9ydCB7dG1wZGlyfSBmcm9tICdvcyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdldmVudHMnO1xuaW1wb3J0IHttZXNzYWdlVHlwZXN9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHR5cGUge09wdGlvbnMsIE1lc3NhZ2VUeXBlfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCBQcm9qZWN0V29ya3NwYWNlIGZyb20gJy4vcHJvamVjdF93b3Jrc3BhY2UnO1xuaW1wb3J0IHtjcmVhdGVQcm9jZXNzfSBmcm9tICcuL1Byb2Nlc3MnO1xuXG4vLyBUaGlzIGNsYXNzIHJlcHJlc2VudHMgdGhlIHJ1bm5pbmcgcHJvY2VzcywgYW5kXG4vLyBwYXNzZXMgb3V0IGV2ZW50cyB3aGVuIGl0IHVuZGVyc3RhbmRzIHdoYXQgZGF0YSBpcyBiZWluZ1xuLy8gcGFzcyBzZW50IG91dCBvZiB0aGUgcHJvY2Vzc1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUnVubmVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgZGVidWdwcm9jZXNzOiBDaGlsZFByb2Nlc3M7XG5cbiAgb3V0cHV0UGF0aDogc3RyaW5nO1xuXG4gIHdvcmtzcGFjZTogUHJvamVjdFdvcmtzcGFjZTtcblxuICBfY3JlYXRlUHJvY2VzczogKHdvcmtzcGFjZTogUHJvamVjdFdvcmtzcGFjZSwgYXJnczogQXJyYXk8c3RyaW5nPikgPT4gQ2hpbGRQcm9jZXNzO1xuXG4gIHdhdGNoTW9kZTogYm9vbGVhbjtcblxuICB3YXRjaEFsbDogYm9vbGVhbjtcblxuICBvcHRpb25zOiBPcHRpb25zO1xuXG4gIHByZXZNZXNzYWdlVHlwZXM6IE1lc3NhZ2VUeXBlW107XG5cbiAgX2V4aXRlZDogYm9vbGVhbjtcblxuICBjb25zdHJ1Y3Rvcih3b3Jrc3BhY2U6IFByb2plY3RXb3Jrc3BhY2UsIG9wdGlvbnM/OiBPcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX2NyZWF0ZVByb2Nlc3MgPSAob3B0aW9ucyAmJiBvcHRpb25zLmNyZWF0ZVByb2Nlc3MpIHx8IGNyZWF0ZVByb2Nlc3M7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLndvcmtzcGFjZSA9IHdvcmtzcGFjZTtcbiAgICB0aGlzLm91dHB1dFBhdGggPSBwYXRoLmpvaW4odG1wZGlyKCksIGBqZXN0X3J1bm5lcl8ke3RoaXMud29ya3NwYWNlLm91dHB1dEZpbGVTdWZmaXggfHwgJyd9Lmpzb25gKTtcbiAgICB0aGlzLnByZXZNZXNzYWdlVHlwZXMgPSBbXTtcbiAgICB0aGlzLl9leGl0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIF9nZXRBcmdzKCk6IHN0cmluZ1tdIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmFyZ3MgJiYgdGhpcy5vcHRpb25zLmFyZ3MucmVwbGFjZSkge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5hcmdzLmFyZ3M7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHRoZSBhcmcgY2hhbmdlIG9uIHYxOFxuICAgIGNvbnN0IGJlbG93RWlnaHRlZW4gPSB0aGlzLndvcmtzcGFjZS5sb2NhbEplc3RNYWpvclZlcnNpb24gPCAxODtcbiAgICBjb25zdCBvdXRwdXRBcmcgPSBiZWxvd0VpZ2h0ZWVuID8gJy0tanNvbk91dHB1dEZpbGUnIDogJy0tb3V0cHV0RmlsZSc7XG4gICAgY29uc3QgYXJncyA9IFsnLS10ZXN0TG9jYXRpb25JblJlc3VsdHMnLCAnLS1qc29uJywgJy0tdXNlU3RkZXJyJywgb3V0cHV0QXJnLCB0aGlzLm91dHB1dFBhdGhdO1xuICAgIGlmICh0aGlzLndhdGNoTW9kZSkge1xuICAgICAgYXJncy5wdXNoKHRoaXMud2F0Y2hBbGwgPyAnLS13YXRjaEFsbCcgOiAnLS13YXRjaCcpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnRlc3ROYW1lUGF0dGVybikge1xuICAgICAgYXJncy5wdXNoKCctLXRlc3ROYW1lUGF0dGVybicsIHRoaXMub3B0aW9ucy50ZXN0TmFtZVBhdHRlcm4pO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnRlc3RGaWxlTmFtZVBhdHRlcm4pIHtcbiAgICAgIGFyZ3MucHVzaCh0aGlzLm9wdGlvbnMudGVzdEZpbGVOYW1lUGF0dGVybik7XG4gICAgfVxuICAgIGlmICh0aGlzLndvcmtzcGFjZS5jb2xsZWN0Q292ZXJhZ2UgPT09IHRydWUpIHtcbiAgICAgIGFyZ3MucHVzaCgnLS1jb3ZlcmFnZScpO1xuICAgIH1cbiAgICBpZiAodGhpcy53b3Jrc3BhY2UuY29sbGVjdENvdmVyYWdlID09PSBmYWxzZSkge1xuICAgICAgYXJncy5wdXNoKCctLW5vLWNvdmVyYWdlJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMubm9Db2xvciA9PT0gdHJ1ZSkge1xuICAgICAgYXJncy5wdXNoKCctLW5vLWNvbG9yJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMucmVwb3J0ZXJzKSB7XG4gICAgICB0aGlzLm9wdGlvbnMucmVwb3J0ZXJzLmZvckVhY2goKHJlcG9ydGVyKSA9PiB7XG4gICAgICAgIGFyZ3MucHVzaCgnLS1yZXBvcnRlcnMnLCByZXBvcnRlcik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5hcmdzKSB7XG4gICAgICBhcmdzLnB1c2goLi4udGhpcy5vcHRpb25zLmFyZ3MuYXJncyk7XG4gICAgfVxuICAgIHJldHVybiBhcmdzO1xuICB9XG5cbiAgc3RhcnQod2F0Y2hNb2RlOiBib29sZWFuID0gdHJ1ZSwgd2F0Y2hBbGw6IGJvb2xlYW4gPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLmRlYnVncHJvY2Vzcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMud2F0Y2hNb2RlID0gd2F0Y2hNb2RlO1xuICAgIHRoaXMud2F0Y2hBbGwgPSB3YXRjaEFsbDtcblxuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9nZXRBcmdzKCk7XG4gICAgdGhpcy5kZWJ1Z3Byb2Nlc3MgPSB0aGlzLl9jcmVhdGVQcm9jZXNzKHRoaXMud29ya3NwYWNlLCBhcmdzKTtcbiAgICB0aGlzLmRlYnVncHJvY2Vzcy5zdGRvdXQub24oJ2RhdGEnLCAoZGF0YTogQnVmZmVyKSA9PiB7XG4gICAgICB0aGlzLl9wYXJzZU91dHB1dChkYXRhLCBmYWxzZSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmRlYnVncHJvY2Vzcy5zdGRlcnIub24oJ2RhdGEnLCAoZGF0YTogQnVmZmVyKSA9PiB7XG4gICAgICAvLyBqZXN0IDIzIGNvdWxkIHNlbmQgdGVzdCByZXN1bHRzIG1lc3NhZ2UgdG8gc3RkZXJyXG4gICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2plc3QvcHVsbC80ODU4XG4gICAgICB0aGlzLl9wYXJzZU91dHB1dChkYXRhLCB0cnVlKTtcbiAgICB9KTtcbiAgICB0aGlzLmRlYnVncHJvY2Vzcy5vbignZXhpdCcsIChjb2RlOiBudW1iZXIgfCBudWxsLCBzaWduYWw6IHN0cmluZyB8IG51bGwpID0+IHtcbiAgICAgIHRoaXMuX2V4aXRlZCA9IHRydWU7XG5cbiAgICAgIC8vIHRoaXMgaXMgbWFpbmx5IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBzaG91bGQgYmUgZGVwcmVjYXRlZCBzb29uXG4gICAgICB0aGlzLmVtaXQoJ2RlYnVnZ2VyUHJvY2Vzc0V4aXQnKTtcblxuICAgICAgdGhpcy5lbWl0KCdwcm9jZXNzRXhpdCcsIGNvZGUsIHNpZ25hbCk7XG4gICAgICB0aGlzLnByZXZNZXNzYWdlVHlwZXMubGVuZ3RoID0gMDtcbiAgICB9KTtcblxuICAgIHRoaXMuZGVidWdwcm9jZXNzLm9uKCdlcnJvcicsIChlcnJvcjogRXJyb3IpID0+IHtcbiAgICAgIHRoaXMuZW1pdCgndGVybWluYWxFcnJvcicsIGBQcm9jZXNzIGZhaWxlZDogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgdGhpcy5wcmV2TWVzc2FnZVR5cGVzLmxlbmd0aCA9IDA7XG4gICAgfSk7XG5cbiAgICB0aGlzLmRlYnVncHJvY2Vzcy5vbignY2xvc2UnLCAoY29kZTogbnVtYmVyIHwgbnVsbCwgc2lnbmFsOiBzdHJpbmcgfCBudWxsKSA9PiB7XG4gICAgICAvLyB0aGlzIGlzIG1haW5seSBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgc2hvdWxkIGJlIGRlcHJlY2F0ZWQgc29vblxuICAgICAgdGhpcy5lbWl0KCdkZWJ1Z2dlclByb2Nlc3NFeGl0Jyk7XG5cbiAgICAgIHRoaXMuZW1pdCgncHJvY2Vzc0Nsb3NlJywgY29kZSwgc2lnbmFsKTtcbiAgICAgIHRoaXMucHJldk1lc3NhZ2VUeXBlcy5sZW5ndGggPSAwO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIHBhcnNlIHRoZSBzdGRpbi9vdXQgc3RyZWFtIGJ1ZmZlciBmb3IgcmVjb2duaXplZCBtZXNzYWdlcy5cbiAgICpcbiAgICogbm90ZTogaWYgdGhlc2UgbWVzc2FnZXMgY29taW5nIGluIGluIHNlcGFyYXRlIGNodWNrcywgd2UgbWlnaHQgbm90IGJlIGFibGUgdG9cbiAgICogcmVzb2x2ZSBpdCBwcm9wZXJseS4gV2hpbGUgdGhlcmUgaGF2ZW4ndCBiZWVuIG11Y2ggZXZpZGVuY2Ugb2Ygc3VjaCBzY2VuYXJpbyxcbiAgICogaXQncyB3b3J0aCB0byBub3RlIHRoYXQgaXQgY291bGQgYW5kIHdlIG1pZ2h0IG5lZWQgdG8gYnVmZmVyIHRoZW0gaW4gdGhhdCBjYXNlLlxuICAgKiBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2plc3QtY29tbXVuaXR5L2plc3QtZWRpdG9yLXN1cHBvcnQvcHVsbC85I3B1bGxyZXF1ZXN0cmV2aWV3LTIzMTg4ODc1MlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzU3RkRXJyXG4gICAqIEByZXR1cm5zIHtNZXNzYWdlVHlwZX1cbiAgICogQG1lbWJlcm9mIFJ1bm5lclxuICAgKi9cbiAgX3BhcnNlT3V0cHV0KGRhdGE6IEJ1ZmZlciwgaXNTdGRFcnI6IGJvb2xlYW4pOiBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3QgbXNnVHlwZSA9IHRoaXMuZmluZE1lc3NhZ2VUeXBlKGRhdGEpO1xuICAgIHN3aXRjaCAobXNnVHlwZSkge1xuICAgICAgY2FzZSBtZXNzYWdlVHlwZXMudGVzdFJlc3VsdHM6XG4gICAgICAgIHRoaXMuZW1pdCgnZXhlY3V0YWJsZVN0ZEVycicsIGRhdGEsIHtcbiAgICAgICAgICB0eXBlOiBtc2dUeXBlLFxuICAgICAgICB9KTtcbiAgICAgICAgcmVhZEZpbGUodGhpcy5vdXRwdXRQYXRoLCAndXRmOCcsIChlcnIsIF9kYXRhKSA9PiB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGBKU09OIHJlcG9ydCBub3QgZm91bmQgYXQgJHt0aGlzLm91dHB1dFBhdGh9YDtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgndGVybWluYWxFcnJvcicsIG1lc3NhZ2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBub1Rlc3RzRm91bmQgPSB0aGlzLmRvUmVzdWx0c0ZvbGxvd05vVGVzdHNGb3VuZE1lc3NhZ2UoKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZXhlY3V0YWJsZUpTT04nLCBKU09OLnBhcnNlKF9kYXRhKSwge1xuICAgICAgICAgICAgICBub1Rlc3RzRm91bmQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnByZXZNZXNzYWdlVHlwZXMubGVuZ3RoID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG1lc3NhZ2VUeXBlcy53YXRjaFVzYWdlOlxuICAgICAgY2FzZSBtZXNzYWdlVHlwZXMubm9UZXN0czpcbiAgICAgICAgdGhpcy5wcmV2TWVzc2FnZVR5cGVzLnB1c2gobXNnVHlwZSk7XG4gICAgICAgIHRoaXMuZW1pdCgnZXhlY3V0YWJsZVN0ZEVycicsIGRhdGEsIHtcbiAgICAgICAgICB0eXBlOiBtc2dUeXBlLFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBubyBzcGVjaWFsIGFjdGlvbiBuZWVkZWQsIGp1c3QgcmVwb3J0IHRoZSBvdXRwdXQgYnkgaXRzIHNvdXJjZVxuICAgICAgICBpZiAoaXNTdGRFcnIpIHtcbiAgICAgICAgICB0aGlzLmVtaXQoJ2V4ZWN1dGFibGVTdGRFcnInLCBkYXRhLCB7XG4gICAgICAgICAgICB0eXBlOiBtc2dUeXBlLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHJlbW92ZSBjbGVhciBzY3JlZW4gZXNjYXBlIHNlcXVlbmNlXG4gICAgICAgICAgdGhpcy5lbWl0KCdleGVjdXRhYmxlT3V0cHV0JywgZGF0YS50b1N0cmluZygpLnJlcGxhY2UoJ1x1MDAxYlsySlx1MDAxYltIJywgJycpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZXZNZXNzYWdlVHlwZXMubGVuZ3RoID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1zZ1R5cGU7XG4gIH1cblxuICBydW5KZXN0V2l0aFVwZGF0ZUZvclNuYXBzaG90cyhjb21wbGV0aW9uOiAoKSA9PiB2b2lkLCBhcmdzPzogc3RyaW5nW10pIHtcbiAgICBjb25zdCBkZWZhdWx0QXJncyA9IFsnLS11cGRhdGVTbmFwc2hvdCddO1xuXG4gICAgY29uc3QgdXBkYXRlUHJvY2VzcyA9IHRoaXMuX2NyZWF0ZVByb2Nlc3ModGhpcy53b3Jrc3BhY2UsIFsuLi5kZWZhdWx0QXJncywgLi4uKGFyZ3MgfHwgW10pXSk7XG4gICAgdXBkYXRlUHJvY2Vzcy5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgICBjb21wbGV0aW9uKCk7XG4gICAgfSk7XG4gIH1cblxuICBjbG9zZVByb2Nlc3MoKSB7XG4gICAgaWYgKCF0aGlzLmRlYnVncHJvY2VzcyB8fCB0aGlzLl9leGl0ZWQpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLmxvZyhgcHJvY2VzcyBoYXMgbm90IHN0YXJ0ZWQgb3IgYWxyZWFkeSBleGl0ZWRgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpIHtcbiAgICAgIC8vIFdpbmRvd3MgZG9lc24ndCBleGl0IHRoZSBwcm9jZXNzIHdoZW4gaXQgc2hvdWxkLlxuICAgICAgc3Bhd24oJ3Rhc2traWxsJywgWycvcGlkJywgYCR7dGhpcy5kZWJ1Z3Byb2Nlc3MucGlkfWAsICcvVCcsICcvRiddKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8ga2lsbCBhbGwgcHJvY2VzcyB3aXRoIHRoZSBzYW1lIFBHSUQsIGkuZS5cbiAgICAgICAgLy8gYXMgYSBkZXRhY2hlZCBwcm9jZXNzLCBpdCBpcyB0aGUgc2FtZSBhcyB0aGUgUElEIG9mIHRoZSBsZWFkZXIgcHJvY2Vzcy5cbiAgICAgICAgcHJvY2Vzcy5raWxsKC10aGlzLmRlYnVncHJvY2Vzcy5waWQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBpZiBhbnl0aGluZyBnb2VzIHdyb25nLCBmYWxsYmFjayB0byB0aGUgb2xkIGJlbmF2aW9yXG4gICAgICAgIC8vIGtub3dpbmcgdGhpcyBjb3VsZCBsZWF2ZSBvcnBoYW4gcHJvY2Vzcy4uLlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgYGZhaWxlZCB0byBraWxsIHByb2Nlc3MgZ3JvdXAsIHRoaXMgY291bGQgbGVhdmUgc29tZSBvcnBoYW4gcHJvY2VzcyB3aG9zZSBwcGlkPSR7dGhpcy5kZWJ1Z3Byb2Nlc3MucGlkfS4gZXJyb3I9YCxcbiAgICAgICAgICBlXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuZGVidWdwcm9jZXNzLmtpbGwoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZGVsZXRlIHRoaXMuZGVidWdwcm9jZXNzO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcbiAgZmluZE1lc3NhZ2VUeXBlKGJ1ZjogQnVmZmVyKTogTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0IG5vVGVzdFJlZ2V4ID0gL05vIHRlc3RzIGZvdW5kIHJlbGF0ZWQgdG8gZmlsZXMgY2hhbmdlZCBzaW5jZSAoKGxhc3QgY29tbWl0KXwoXCJbYS16MC05XStcIikpLi87XG4gICAgY29uc3Qgd2F0Y2hVc2FnZVJlZ2V4ID0gL15cXHMqV2F0Y2ggVXNhZ2VcXGIvO1xuICAgIGNvbnN0IHRlc3RSZXN1bHRzUmVnZXggPSAvVGVzdCByZXN1bHRzIHdyaXR0ZW4gdG8vO1xuXG4gICAgY29uc3QgY2hlY2tzID0gW1xuICAgICAge3JlZ2V4OiB0ZXN0UmVzdWx0c1JlZ2V4LCBtZXNzYWdlVHlwZTogbWVzc2FnZVR5cGVzLnRlc3RSZXN1bHRzfSxcbiAgICAgIHtyZWdleDogbm9UZXN0UmVnZXgsIG1lc3NhZ2VUeXBlOiBtZXNzYWdlVHlwZXMubm9UZXN0c30sXG4gICAgICB7cmVnZXg6IHdhdGNoVXNhZ2VSZWdleCwgbWVzc2FnZVR5cGU6IG1lc3NhZ2VUeXBlcy53YXRjaFVzYWdlfSxcbiAgICBdO1xuXG4gICAgY29uc3Qgc3RyID0gYnVmLnRvU3RyaW5nKCd1dGY4Jyk7XG4gICAgY29uc3QgbWF0Y2ggPSBjaGVja3MuZmluZCgoe3JlZ2V4fSkgPT4gcmVnZXgudGVzdChzdHIpKTtcbiAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaC5tZXNzYWdlVHlwZSA6IG1lc3NhZ2VUeXBlcy51bmtub3duO1xuICB9XG5cbiAgZG9SZXN1bHRzRm9sbG93Tm9UZXN0c0ZvdW5kTWVzc2FnZSgpIHtcbiAgICBpZiAodGhpcy5wcmV2TWVzc2FnZVR5cGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHRoaXMucHJldk1lc3NhZ2VUeXBlc1swXSA9PT0gbWVzc2FnZVR5cGVzLm5vVGVzdHM7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucHJldk1lc3NhZ2VUeXBlcy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHJldHVybiB0aGlzLnByZXZNZXNzYWdlVHlwZXNbMF0gPT09IG1lc3NhZ2VUeXBlcy5ub1Rlc3RzICYmIHRoaXMucHJldk1lc3NhZ2VUeXBlc1sxXSA9PT0gbWVzc2FnZVR5cGVzLndhdGNoVXNhZ2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG4iXX0=