"use strict";

require("core-js/modules/es.object.define-property.js");

require("core-js/modules/es.array.is-array.js");

require("core-js/modules/es.symbol.js");

require("core-js/modules/es.symbol.description.js");

require("core-js/modules/es.symbol.iterator.js");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.string.iterator.js");

require("core-js/modules/web.dom-collections.iterator.js");

require("core-js/modules/es.array.slice.js");

require("core-js/modules/es.array.from.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

require("regenerator-runtime/runtime.js");

require("core-js/modules/es.object.assign.js");

require("core-js/modules/es.object.create.js");

require("core-js/modules/es.function.name.js");

require("core-js/modules/es.array.join.js");

require("core-js/modules/es.array.map.js");

require("core-js/modules/es.array.concat.js");

require("core-js/modules/es.object.to-string.js");

require("core-js/modules/es.promise.js");

require("core-js/modules/es.array.index-of.js");

require("core-js/modules/es.array.filter.js");

require("core-js/modules/es.array.for-each.js");

require("core-js/modules/web.dom-collections.for-each.js");

require("core-js/modules/es.object.entries.js");

var _traverse = _interopRequireDefault(require("@babel/traverse"));

var _jestSnapshot = require("jest-snapshot");

var _babel_parser = require("./parsers/babel_parser");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var describeVariants = Object.assign(Object.create(null), {
  describe: true,
  fdescribe: true,
  xdescribe: true
});
var base = Object.assign(Object.create(null), {
  describe: true,
  it: true,
  test: true
});
var decorators = Object.assign(Object.create(null), {
  only: true,
  skip: true
});
var validParents = Object.assign(Object.create(null), base, describeVariants, Object.assign(Object.create(null), {
  fit: true,
  xit: true,
  xtest: true
}));

var isValidMemberExpression = function isValidMemberExpression(node) {
  return node.object && base[node.object.name] && node.property && decorators[node.property.name];
};

var isDescribe = function isDescribe(node) {
  return describeVariants[node.name] || isValidMemberExpression(node) && node.object.name === 'describe';
};

var isValidParent = function isValidParent(parent) {
  return parent.callee && (validParents[parent.callee.name] || isValidMemberExpression(parent.callee));
};

var getArrayOfParents = function getArrayOfParents(path) {
  var result = [];
  var parent = path.parentPath;

  while (parent) {
    result.unshift(parent.node);
    parent = parent.parentPath;
  }

  return result;
};

var buildName = function buildName(snapshotNode, parents, position) {
  var fullName = parents.map(function (parent) {
    return parent.arguments[0].value;
  }).join(' ');
  return _jestSnapshot.utils.testNameToKey(fullName, position);
};

var Snapshot = /*#__PURE__*/function () {
  function Snapshot(parser, customMatchers, projectConfig) {
    var _this = this;

    _classCallCheck(this, Snapshot);

    this._parser = parser || _babel_parser.getASTfor;
    this._matchers = ['toMatchSnapshot', 'toThrowErrorMatchingSnapshot'].concat(customMatchers || []);
    this._projectConfig = projectConfig;
    this._resolverPromise = (0, _jestSnapshot.buildSnapshotResolver)(this._projectConfig || {}, function () {
      return Promise.resolve();
    }).then(function (resolver) {
      _this.snapshotResolver = resolver;
    });
  }

  _createClass(Snapshot, [{
    key: "parse",
    value: function parse(filePath) {
      var _this2 = this;

      var verbose = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var fileNode;

      try {
        fileNode = this._parser(filePath);
      } catch (error) {
        if (verbose) {
          // eslint-disable-next-line no-console
          console.warn(error);
        }

        return [];
      }

      var Visitors = {
        Identifier: function Identifier(path, found, matchers) {
          if (matchers.indexOf(path.node.name) >= 0) {
            found.push({
              node: path.node,
              parents: getArrayOfParents(path)
            });
          }
        }
      };
      var found = [];
      (0, _traverse["default"])(fileNode, {
        enter: function enter(path) {
          var visitor = Visitors[path.node.type];

          if (visitor != null) {
            visitor(path, found, _this2._matchers);
          }
        }
      });
      return found.map(function (f) {
        return {
          node: f.node,
          parents: f.parents.filter(isValidParent)
        };
      });
    }
  }, {
    key: "_getSnapshotResolver",
    value: function () {
      var _getSnapshotResolver2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (this.snapshotResolver) {
                  _context.next = 3;
                  break;
                }

                _context.next = 3;
                return this._resolverPromise;

              case 3:
                return _context.abrupt("return", this.snapshotResolver);

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function _getSnapshotResolver() {
        return _getSnapshotResolver2.apply(this, arguments);
      }

      return _getSnapshotResolver;
    }()
    /**
     * look for snapshot content for the given test.
     * @param {*} filePath
     * @param {*} name can be a literal string or a regex pattern.
     * @returns the content of the snapshot, if exist. If name is a string, a string will be returned. If name is a RegExp,
     * a SnapshotData object will be returned with all matched snapshots. If nothing matched, null will be returned.
     * @throws throws exception if the snapshot version mismatched or any other unexpected error.
     */

  }, {
    key: "getSnapshotContent",
    value: function () {
      var _getSnapshotContent = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(filePath, name) {
        var snapshotResolver, snapshotPath, snapshots, regex, data;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this._getSnapshotResolver();

              case 2:
                snapshotResolver = _context2.sent;
                snapshotPath = snapshotResolver.resolveSnapshotPath(filePath);
                snapshots = _jestSnapshot.utils.getSnapshotData(snapshotPath, 'none').data;

                if (!(typeof name === 'string')) {
                  _context2.next = 7;
                  break;
                }

                return _context2.abrupt("return", snapshots[name]);

              case 7:
                regex = name;
                data = {};
                Object.entries(snapshots).forEach(function (_ref) {
                  var _ref2 = _slicedToArray(_ref, 2),
                      key = _ref2[0],
                      value = _ref2[1];

                  if (regex.test(key)) {
                    data[key] = value;
                  }
                });
                return _context2.abrupt("return", Object.entries(data).length > 0 ? data : null);

              case 11:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getSnapshotContent(_x, _x2) {
        return _getSnapshotContent.apply(this, arguments);
      }

      return getSnapshotContent;
    }()
  }, {
    key: "getMetadataAsync",
    value: function () {
      var _getMetadataAsync = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(filePath) {
        var verbose,
            _args3 = arguments;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                verbose = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : false;
                _context3.next = 3;
                return this._getSnapshotResolver();

              case 3:
                return _context3.abrupt("return", this.getMetadata(filePath, verbose));

              case 4:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getMetadataAsync(_x3) {
        return _getMetadataAsync.apply(this, arguments);
      }

      return getMetadataAsync;
    }()
  }, {
    key: "getMetadata",
    value: function getMetadata(filePath) {
      var verbose = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (!this.snapshotResolver) {
        throw new Error('snapshotResolver is not ready yet, consider migrating to "getMetadataAsync" instead');
      }

      var snapshotPath = this.snapshotResolver.resolveSnapshotPath(filePath);
      var snapshotNodes = this.parse(filePath, verbose);

      var snapshots = _jestSnapshot.utils.getSnapshotData(snapshotPath, 'none').data;

      var lastParent = null;
      var count = 1;
      return snapshotNodes.map(function (snapshotNode) {
        var parents = snapshotNode.parents;
        var innerAssertion = parents[parents.length - 1];

        if (lastParent !== innerAssertion) {
          lastParent = innerAssertion;
          count = 1;
        }

        var result = {
          content: undefined,
          count: count,
          exists: false,
          name: '',
          node: snapshotNode.node
        };
        count += 1;

        if (!innerAssertion || isDescribe(innerAssertion.callee)) {
          // An expectation inside describe never gets executed.
          return result;
        }

        result.name = buildName(snapshotNode, parents, result.count);

        if (snapshots[result.name]) {
          result.exists = true;
          result.content = snapshots[result.name];
        }

        return result;
      });
    }
  }]);

  return Snapshot;
}();

exports["default"] = Snapshot;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9TbmFwc2hvdC5qcyJdLCJuYW1lcyI6WyJkZXNjcmliZVZhcmlhbnRzIiwiT2JqZWN0IiwiYXNzaWduIiwiY3JlYXRlIiwiZGVzY3JpYmUiLCJmZGVzY3JpYmUiLCJ4ZGVzY3JpYmUiLCJiYXNlIiwiaXQiLCJ0ZXN0IiwiZGVjb3JhdG9ycyIsIm9ubHkiLCJza2lwIiwidmFsaWRQYXJlbnRzIiwiZml0IiwieGl0IiwieHRlc3QiLCJpc1ZhbGlkTWVtYmVyRXhwcmVzc2lvbiIsIm5vZGUiLCJvYmplY3QiLCJuYW1lIiwicHJvcGVydHkiLCJpc0Rlc2NyaWJlIiwiaXNWYWxpZFBhcmVudCIsInBhcmVudCIsImNhbGxlZSIsImdldEFycmF5T2ZQYXJlbnRzIiwicGF0aCIsInJlc3VsdCIsInBhcmVudFBhdGgiLCJ1bnNoaWZ0IiwiYnVpbGROYW1lIiwic25hcHNob3ROb2RlIiwicGFyZW50cyIsInBvc2l0aW9uIiwiZnVsbE5hbWUiLCJtYXAiLCJhcmd1bWVudHMiLCJ2YWx1ZSIsImpvaW4iLCJ1dGlscyIsInRlc3ROYW1lVG9LZXkiLCJTbmFwc2hvdCIsInBhcnNlciIsImN1c3RvbU1hdGNoZXJzIiwicHJvamVjdENvbmZpZyIsIl9wYXJzZXIiLCJnZXRBU1Rmb3IiLCJfbWF0Y2hlcnMiLCJjb25jYXQiLCJfcHJvamVjdENvbmZpZyIsIl9yZXNvbHZlclByb21pc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsInRoZW4iLCJyZXNvbHZlciIsInNuYXBzaG90UmVzb2x2ZXIiLCJmaWxlUGF0aCIsInZlcmJvc2UiLCJmaWxlTm9kZSIsImVycm9yIiwiY29uc29sZSIsIndhcm4iLCJWaXNpdG9ycyIsIklkZW50aWZpZXIiLCJmb3VuZCIsIm1hdGNoZXJzIiwiaW5kZXhPZiIsInB1c2giLCJlbnRlciIsInZpc2l0b3IiLCJ0eXBlIiwiZiIsImZpbHRlciIsIl9nZXRTbmFwc2hvdFJlc29sdmVyIiwic25hcHNob3RQYXRoIiwicmVzb2x2ZVNuYXBzaG90UGF0aCIsInNuYXBzaG90cyIsImdldFNuYXBzaG90RGF0YSIsImRhdGEiLCJyZWdleCIsImVudHJpZXMiLCJmb3JFYWNoIiwia2V5IiwibGVuZ3RoIiwiZ2V0TWV0YWRhdGEiLCJFcnJvciIsInNuYXBzaG90Tm9kZXMiLCJwYXJzZSIsImxhc3RQYXJlbnQiLCJjb3VudCIsImlubmVyQXNzZXJ0aW9uIiwiY29udGVudCIsInVuZGVmaW5lZCIsImV4aXN0cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVVBOztBQUNBOztBQUdBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVdBLElBQU1BLGdCQUFnQixHQUFHQyxNQUFNLENBQUNDLE1BQVAsQ0FBZUQsTUFBTSxDQUFDRSxNQUFQLENBQWMsSUFBZCxDQUFmLEVBQTJFO0FBQ2xHQyxFQUFBQSxRQUFRLEVBQUUsSUFEd0Y7QUFFbEdDLEVBQUFBLFNBQVMsRUFBRSxJQUZ1RjtBQUdsR0MsRUFBQUEsU0FBUyxFQUFFO0FBSHVGLENBQTNFLENBQXpCO0FBS0EsSUFBTUMsSUFBSSxHQUFHTixNQUFNLENBQUNDLE1BQVAsQ0FBZUQsTUFBTSxDQUFDRSxNQUFQLENBQWMsSUFBZCxDQUFmLEVBQTJFO0FBQ3RGQyxFQUFBQSxRQUFRLEVBQUUsSUFENEU7QUFFdEZJLEVBQUFBLEVBQUUsRUFBRSxJQUZrRjtBQUd0RkMsRUFBQUEsSUFBSSxFQUFFO0FBSGdGLENBQTNFLENBQWI7QUFLQSxJQUFNQyxVQUFVLEdBQUdULE1BQU0sQ0FBQ0MsTUFBUCxDQUFlRCxNQUFNLENBQUNFLE1BQVAsQ0FBYyxJQUFkLENBQWYsRUFBMkU7QUFDNUZRLEVBQUFBLElBQUksRUFBRSxJQURzRjtBQUU1RkMsRUFBQUEsSUFBSSxFQUFFO0FBRnNGLENBQTNFLENBQW5CO0FBS0EsSUFBTUMsWUFBWSxHQUFHWixNQUFNLENBQUNDLE1BQVAsQ0FDbEJELE1BQU0sQ0FBQ0UsTUFBUCxDQUFjLElBQWQsQ0FEa0IsRUFF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QU9DLE9BQVAsR0FBa0JELFlBQWxCLENBQU9DLE9BQVA7QUFDQSxZQUFNMEQsY0FBYyxHQUFHMUQsT0FBTyxDQUFDQSxPQUFPLENBQUNtRCxNQUFSLEdBQWlCLENBQWxCLENBQTlCOztBQUVBLFlBQUlLLFVBQVUsS0FBS0UsY0FBbkIsRUFBbUM7QUFDakNGLFVBQUFBLFVBQVUsR0FBR0UsY0FBYjtBQUNBRCxVQUFBQSxLQUFLLEdBQUcsQ0FBUjtBQUNEOztBQUVELFlBQU05RCxNQUFNLEdBQUc7QUFDYmdFLFVBQUFBLE9BQU8sRUFBRUMsU0FESTtBQUViSCxVQUFBQSxLQUFLLEVBQUxBLEtBRmE7QUFHYkksVUFBQUEsTUFBTSxFQUFFLEtBSEs7QUFJYjFFLFVBQUFBLElBQUksRUFBRSxFQUpPO0FBS2JGLFVBQUFBLElBQUksRUFBRWMsWUFBWSxDQUFDZDtBQUxOLFNBQWY7QUFPQXdFLFFBQUFBLEtBQUssSUFBSSxDQUFUOztBQUVBLFlBQUksQ0FBQ0MsY0FBRCxJQUFtQnJFLFVBQVUsQ0FBQ3FFLGNBQWMsQ0FBQ2xFLE1BQWhCLENBQWpDLEVBQTBEO0FBQ3hEO0FBQ0EsaUJBQU9HLE1BQVA7QUFDRDs7QUFFREEsUUFBQUEsTUFBTSxDQUFDUixJQUFQLEdBQWNXLFNBQVMsQ0FBQ0MsWUFBRCxFQUFlQyxPQUFmLEVBQXdCTCxNQUFNLENBQUM4RCxLQUEvQixDQUF2Qjs7QUFFQSxZQUFJYixTQUFTLENBQUNqRCxNQUFNLENBQUNSLElBQVIsQ0FBYixFQUE0QjtBQUMxQlEsVUFBQUEsTUFBTSxDQUFDa0UsTUFBUCxHQUFnQixJQUFoQjtBQUNBbEUsVUFBQUEsTUFBTSxDQUFDZ0UsT0FBUCxHQUFpQmYsU0FBUyxDQUFDakQsTUFBTSxDQUFDUixJQUFSLENBQTFCO0FBQ0Q7O0FBQ0QsZUFBT1EsTUFBUDtBQUNELE9BOUJNLENBQVA7QUErQkQiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmltcG9ydCB0cmF2ZXJzZSBmcm9tICdAYmFiZWwvdHJhdmVyc2UnO1xuaW1wb3J0IHtidWlsZFNuYXBzaG90UmVzb2x2ZXIsIFNuYXBzaG90UmVzb2x2ZXIsIHV0aWxzLCBTbmFwc2hvdERhdGF9IGZyb20gJ2plc3Qtc25hcHNob3QnO1xuaW1wb3J0IHR5cGUge1Byb2plY3RDb25maWd9IGZyb20gJy4uL3R5cGVzL0NvbmZpZyc7XG5cbmltcG9ydCB7Z2V0QVNUZm9yfSBmcm9tICcuL3BhcnNlcnMvYmFiZWxfcGFyc2VyJztcblxudHlwZSBOb2RlID0gYW55O1xuXG50eXBlIFNuYXBzaG90TWV0YWRhdGEgPSB7XG4gIGV4aXN0czogdHJ1ZSB8IGZhbHNlLFxuICBuYW1lOiBzdHJpbmcsXG4gIG5vZGU6IE5vZGUsXG4gIGNvbnRlbnQ/OiBzdHJpbmcsXG59O1xuXG5jb25zdCBkZXNjcmliZVZhcmlhbnRzID0gT2JqZWN0LmFzc2lnbigoT2JqZWN0LmNyZWF0ZShudWxsKToge1tzdHJpbmddOiBib29sZWFuLCBfX3Byb3RvX186IG51bGx9KSwge1xuICBkZXNjcmliZTogdHJ1ZSxcbiAgZmRlc2NyaWJlOiB0cnVlLFxuICB4ZGVzY3JpYmU6IHRydWUsXG59KTtcbmNvbnN0IGJhc2UgPSBPYmplY3QuYXNzaWduKChPYmplY3QuY3JlYXRlKG51bGwpOiB7W3N0cmluZ106IGJvb2xlYW4sIF9fcHJvdG9fXzogbnVsbH0pLCB7XG4gIGRlc2NyaWJlOiB0cnVlLFxuICBpdDogdHJ1ZSxcbiAgdGVzdDogdHJ1ZSxcbn0pO1xuY29uc3QgZGVjb3JhdG9ycyA9IE9iamVjdC5hc3NpZ24oKE9iamVjdC5jcmVhdGUobnVsbCk6IHtbc3RyaW5nXTogYm9vbGVhbiwgX19wcm90b19fOiBudWxsfSksIHtcbiAgb25seTogdHJ1ZSxcbiAgc2tpcDogdHJ1ZSxcbn0pO1xuXG5jb25zdCB2YWxpZFBhcmVudHMgPSBPYmplY3QuYXNzaWduKFxuICAoT2JqZWN0LmNyZWF0ZShudWxsKTogYW55KSxcbiAgYmFzZSxcbiAgZGVzY3JpYmVWYXJpYW50cyxcbiAgT2JqZWN0LmFzc2lnbigoT2JqZWN0LmNyZWF0ZShudWxsKToge1tzdHJpbmddOiBib29sZWFuLCBfX3Byb3RvX186IG51bGx9KSwge1xuICAgIGZpdDogdHJ1ZSxcbiAgICB4aXQ6IHRydWUsXG4gICAgeHRlc3Q6IHRydWUsXG4gIH0pXG4pO1xuXG5jb25zdCBpc1ZhbGlkTWVtYmVyRXhwcmVzc2lvbiA9IChub2RlKSA9PlxuICBub2RlLm9iamVjdCAmJiBiYXNlW25vZGUub2JqZWN0Lm5hbWVdICYmIG5vZGUucHJvcGVydHkgJiYgZGVjb3JhdG9yc1tub2RlLnByb3BlcnR5Lm5hbWVdO1xuXG5jb25zdCBpc0Rlc2NyaWJlID0gKG5vZGUpID0+XG4gIGRlc2NyaWJlVmFyaWFudHNbbm9kZS5uYW1lXSB8fCAoaXNWYWxpZE1lbWJlckV4cHJlc3Npb24obm9kZSkgJiYgbm9kZS5vYmplY3QubmFtZSA9PT0gJ2Rlc2NyaWJlJyk7XG5cbmNvbnN0IGlzVmFsaWRQYXJlbnQgPSAocGFyZW50KSA9PlxuICBwYXJlbnQuY2FsbGVlICYmICh2YWxpZFBhcmVudHNbcGFyZW50LmNhbGxlZS5uYW1lXSB8fCBpc1ZhbGlkTWVtYmVyRXhwcmVzc2lvbihwYXJlbnQuY2FsbGVlKSk7XG5cbmNvbnN0IGdldEFycmF5T2ZQYXJlbnRzID0gKHBhdGgpID0+IHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBwYXJlbnQgPSBwYXRoLnBhcmVudFBhdGg7XG4gIHdoaWxlIChwYXJlbnQpIHtcbiAgICByZXN1bHQudW5zaGlmdChwYXJlbnQubm9kZSk7XG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudFBhdGg7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmNvbnN0IGJ1aWxkTmFtZTogKHNuYXBzaG90Tm9kZTogTm9kZSwgcGFyZW50czogQXJyYXk8Tm9kZT4sIHBvc2l0aW9uOiBudW1iZXIpID0+IHN0cmluZyA9IChcbiAgc25hcHNob3ROb2RlLFxuICBwYXJlbnRzLFxuICBwb3NpdGlvblxuKSA9PiB7XG4gIGNvbnN0IGZ1bGxOYW1lID0gcGFyZW50cy5tYXAoKHBhcmVudCkgPT4gcGFyZW50LmFyZ3VtZW50c1swXS52YWx1ZSkuam9pbignICcpO1xuXG4gIHJldHVybiB1dGlscy50ZXN0TmFtZVRvS2V5KGZ1bGxOYW1lLCBwb3NpdGlvbik7XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIFNuYXBzaG90Tm9kZSB7XG4gIG5vZGU6IE5vZGU7XG4gIHBhcmVudHM6IE5vZGVbXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU25hcHNob3Qge1xuICBfcGFyc2VyOiBGdW5jdGlvbjtcblxuICBfbWF0Y2hlcnM6IEFycmF5PHN0cmluZz47XG5cbiAgX3Byb2plY3RDb25maWc6ID9Qcm9qZWN0Q29uZmlnO1xuXG4gIHNuYXBzaG90UmVzb2x2ZXI6ID9TbmFwc2hvdFJlc29sdmVyO1xuXG4gIF9yZXNvbHZlclByb21pc2U6IFByb21pc2U8U25hcHNob3RSZXNvbHZlcj47XG5cbiAgY29uc3RydWN0b3IocGFyc2VyOiBhbnksIGN1c3RvbU1hdGNoZXJzPzogQXJyYXk8c3RyaW5nPiwgcHJvamVjdENvbmZpZz86IFByb2plY3RDb25maWcpIHtcbiAgICB0aGlzLl9wYXJzZXIgPSBwYXJzZXIgfHwgZ2V0QVNUZm9yO1xuICAgIHRoaXMuX21hdGNoZXJzID0gWyd0b01hdGNoU25hcHNob3QnLCAndG9UaHJvd0Vycm9yTWF0Y2hpbmdTbmFwc2hvdCddLmNvbmNhdChjdXN0b21NYXRjaGVycyB8fCBbXSk7XG4gICAgdGhpcy5fcHJvamVjdENvbmZpZyA9IHByb2plY3RDb25maWc7XG4gICAgdGhpcy5fcmVzb2x2ZXJQcm9taXNlID0gYnVpbGRTbmFwc2hvdFJlc29sdmVyKHRoaXMuX3Byb2plY3RDb25maWcgfHwge30sICgpID0+IFByb21pc2UucmVzb2x2ZSgpKS50aGVuKFxuICAgICAgKHJlc29sdmVyKSA9PiB7XG4gICAgICAgIHRoaXMuc25hcHNob3RSZXNvbHZlciA9IHJlc29sdmVyO1xuICAgICAgfVxuICAgICk7XG4gIH1cblxuICBwYXJzZShmaWxlUGF0aDogc3RyaW5nLCB2ZXJib3NlOiBib29sZWFuID0gZmFsc2UpOiBTbmFwc2hvdE5vZGVbXSB7XG4gICAgbGV0IGZpbGVOb2RlO1xuICAgIHRyeSB7XG4gICAgICBmaWxlTm9kZSA9IHRoaXMuX3BhcnNlcihmaWxlUGF0aCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmICh2ZXJib3NlKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgIGNvbnNvbGUud2FybihlcnJvcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3QgVmlzaXRvcnMgPSB7XG4gICAgICBJZGVudGlmaWVyKHBhdGgsIGZvdW5kLCBtYXRjaGVycykge1xuICAgICAgICBpZiAobWF0Y2hlcnMuaW5kZXhPZihwYXRoLm5vZGUubmFtZSkgPj0gMCkge1xuICAgICAgICAgIGZvdW5kLnB1c2goe1xuICAgICAgICAgICAgbm9kZTogcGF0aC5ub2RlLFxuICAgICAgICAgICAgcGFyZW50czogZ2V0QXJyYXlPZlBhcmVudHMocGF0aCksXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfTtcblxuICAgIGNvbnN0IGZvdW5kID0gW107XG5cbiAgICB0cmF2ZXJzZShmaWxlTm9kZSwge1xuICAgICAgZW50ZXI6IChwYXRoKSA9PiB7XG4gICAgICAgIGNvbnN0IHZpc2l0b3IgPSBWaXNpdG9yc1twYXRoLm5vZGUudHlwZV07XG4gICAgICAgIGlmICh2aXNpdG9yICE9IG51bGwpIHtcbiAgICAgICAgICB2aXNpdG9yKHBhdGgsIGZvdW5kLCB0aGlzLl9tYXRjaGVycyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICByZXR1cm4gZm91bmQubWFwKChmKSA9PiAoe1xuICAgICAgbm9kZTogZi5ub2RlLFxuICAgICAgcGFyZW50czogZi5wYXJlbnRzLmZpbHRlcihpc1ZhbGlkUGFyZW50KSxcbiAgICB9KSk7XG4gIH1cblxuICBhc3luYyBfZ2V0U25hcHNob3RSZXNvbHZlcigpOiBQcm9taXNlPFNuYXBzaG90UmVzb2x2ZXI+IHtcbiAgICBpZiAoIXRoaXMuc25hcHNob3RSZXNvbHZlcikge1xuICAgICAgYXdhaXQgdGhpcy5fcmVzb2x2ZXJQcm9taXNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zbmFwc2hvdFJlc29sdmVyO1xuICB9XG5cbiAgLyoqXG4gICAqIGxvb2sgZm9yIHNuYXBzaG90IGNvbnRlbnQgZm9yIHRoZSBnaXZlbiB0ZXN0LlxuICAgKiBAcGFyYW0geyp9IGZpbGVQYXRoXG4gICAqIEBwYXJhbSB7Kn0gbmFtZSBjYW4gYmUgYSBsaXRlcmFsIHN0cmluZyBvciBhIHJlZ2V4IHBhdHRlcm4uXG4gICAqIEByZXR1cm5zIHRoZSBjb250ZW50IG9mIHRoZSBzbmFwc2hvdCwgaWYgZXhpc3QuIElmIG5hbWUgaXMgYSBzdHJpbmcsIGEgc3RyaW5nIHdpbGwgYmUgcmV0dXJuZWQuIElmIG5hbWUgaXMgYSBSZWdFeHAsXG4gICAqIGEgU25hcHNob3REYXRhIG9iamVjdCB3aWxsIGJlIHJldHVybmVkIHdpdGggYWxsIG1hdGNoZWQgc25hcHNob3RzLiBJZiBub3RoaW5nIG1hdGNoZWQsIG51bGwgd2lsbCBiZSByZXR1cm5lZC5cbiAgICogQHRocm93cyB0aHJvd3MgZXhjZXB0aW9uIGlmIHRoZSBzbmFwc2hvdCB2ZXJzaW9uIG1pc21hdGNoZWQgb3IgYW55IG90aGVyIHVuZXhwZWN0ZWQgZXJyb3IuXG4gICAqL1xuICBhc3luYyBnZXRTbmFwc2hvdENvbnRlbnQoZmlsZVBhdGg6IHN0cmluZywgbmFtZTogc3RyaW5nIHwgUmVnRXhwKTogUHJvbWlzZTxzdHJpbmcgfCBTbmFwc2hvdERhdGEgfCBudWxsPiB7XG4gICAgY29uc3Qgc25hcHNob3RSZXNvbHZlciA9IGF3YWl0IHRoaXMuX2dldFNuYXBzaG90UmVzb2x2ZXIoKTtcblxuICAgIGNvbnN0IHNuYXBzaG90UGF0aCA9IHNuYXBzaG90UmVzb2x2ZXIucmVzb2x2ZVNuYXBzaG90UGF0aChmaWxlUGF0aCk7XG4gICAgY29uc3Qgc25hcHNob3RzID0gdXRpbHMuZ2V0U25hcHNob3REYXRhKHNuYXBzaG90UGF0aCwgJ25vbmUnKS5kYXRhO1xuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBzbmFwc2hvdHNbbmFtZV07XG4gICAgfVxuICAgIGNvbnN0IHJlZ2V4ID0gbmFtZTtcbiAgICBjb25zdCBkYXRhOiBTbmFwc2hvdERhdGEgPSB7fTtcbiAgICBPYmplY3QuZW50cmllcyhzbmFwc2hvdHMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgaWYgKHJlZ2V4LnRlc3Qoa2V5KSkge1xuICAgICAgICBkYXRhW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMoZGF0YSkubGVuZ3RoID4gMCA/IGRhdGEgOiBudWxsO1xuICB9XG5cbiAgYXN5bmMgZ2V0TWV0YWRhdGFBc3luYyhmaWxlUGF0aDogc3RyaW5nLCB2ZXJib3NlOiBib29sZWFuID0gZmFsc2UpOiBQcm9taXNlPEFycmF5PFNuYXBzaG90TWV0YWRhdGE+PiB7XG4gICAgYXdhaXQgdGhpcy5fZ2V0U25hcHNob3RSZXNvbHZlcigpO1xuICAgIHJldHVybiB0aGlzLmdldE1ldGFkYXRhKGZpbGVQYXRoLCB2ZXJib3NlKTtcbiAgfVxuXG4gIGdldE1ldGFkYXRhKGZpbGVQYXRoOiBzdHJpbmcsIHZlcmJvc2U6IGJvb2xlYW4gPSBmYWxzZSk6IEFycmF5PFNuYXBzaG90TWV0YWRhdGE+IHtcbiAgICBpZiAoIXRoaXMuc25hcHNob3RSZXNvbHZlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzbmFwc2hvdFJlc29sdmVyIGlzIG5vdCByZWFkeSB5ZXQsIGNvbnNpZGVyIG1pZ3JhdGluZyB0byBcImdldE1ldGFkYXRhQXN5bmNcIiBpbnN0ZWFkJyk7XG4gICAgfVxuICAgIGNvbnN0IHNuYXBzaG90UGF0aCA9IHRoaXMuc25hcHNob3RSZXNvbHZlci5yZXNvbHZlU25hcHNob3RQYXRoKGZpbGVQYXRoKTtcbiAgICBjb25zdCBzbmFwc2hvdE5vZGVzID0gdGhpcy5wYXJzZShmaWxlUGF0aCwgdmVyYm9zZSk7XG4gICAgY29uc3Qgc25hcHNob3RzID0gdXRpbHMuZ2V0U25hcHNob3REYXRhKHNuYXBzaG90UGF0aCwgJ25vbmUnKS5kYXRhO1xuXG4gICAgbGV0IGxhc3RQYXJlbnQgPSBudWxsO1xuICAgIGxldCBjb3VudCA9IDE7XG5cbiAgICByZXR1cm4gc25hcHNob3ROb2Rlcy5tYXAoKHNuYXBzaG90Tm9kZSkgPT4ge1xuICAgICAgY29uc3Qge3BhcmVudHN9ID0gc25hcHNob3ROb2RlO1xuICAgICAgY29uc3QgaW5uZXJBc3NlcnRpb24gPSBwYXJlbnRzW3BhcmVudHMubGVuZ3RoIC0gMV07XG5cbiAgICAgIGlmIChsYXN0UGFyZW50ICE9PSBpbm5lckFzc2VydGlvbikge1xuICAgICAgICBsYXN0UGFyZW50ID0gaW5uZXJBc3NlcnRpb247XG4gICAgICAgIGNvdW50ID0gMTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICBjb250ZW50OiB1bmRlZmluZWQsXG4gICAgICAgIGNvdW50LFxuICAgICAgICBleGlzdHM6IGZhbHNlLFxuICAgICAgICBuYW1lOiAnJyxcbiAgICAgICAgbm9kZTogc25hcHNob3ROb2RlLm5vZGUsXG4gICAgICB9O1xuICAgICAgY291bnQgKz0gMTtcblxuICAgICAgaWYgKCFpbm5lckFzc2VydGlvbiB8fCBpc0Rlc2NyaWJlKGlubmVyQXNzZXJ0aW9uLmNhbGxlZSkpIHtcbiAgICAgICAgLy8gQW4gZXhwZWN0YXRpb24gaW5zaWRlIGRlc2NyaWJlIG5ldmVyIGdldHMgZXhlY3V0ZWQuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdC5uYW1lID0gYnVpbGROYW1lKHNuYXBzaG90Tm9kZSwgcGFyZW50cywgcmVzdWx0LmNvdW50KTtcblxuICAgICAgaWYgKHNuYXBzaG90c1tyZXN1bHQubmFtZV0pIHtcbiAgICAgICAgcmVzdWx0LmV4aXN0cyA9IHRydWU7XG4gICAgICAgIHJlc3VsdC5jb250ZW50ID0gc25hcHNob3RzW3Jlc3VsdC5uYW1lXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG4gIH1cbn1cbiJdfQ==