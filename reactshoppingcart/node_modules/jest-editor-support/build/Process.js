"use strict";

require("core-js/modules/es.symbol.js");

require("core-js/modules/es.symbol.description.js");

require("core-js/modules/es.object.to-string.js");

require("core-js/modules/es.symbol.iterator.js");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.string.iterator.js");

require("core-js/modules/web.dom-collections.iterator.js");

require("core-js/modules/es.array.from.js");

require("core-js/modules/es.array.slice.js");

require("core-js/modules/es.function.name.js");

require("core-js/modules/es.object.define-property.js");

require("core-js/modules/es.object.keys.js");

require("core-js/modules/es.array.filter.js");

require("core-js/modules/es.object.get-own-property-descriptor.js");

require("core-js/modules/es.array.for-each.js");

require("core-js/modules/web.dom-collections.for-each.js");

require("core-js/modules/es.object.get-own-property-descriptors.js");

require("core-js/modules/es.object.define-properties.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createProcess = void 0;

require("core-js/modules/es.array.is-array.js");

require("core-js/modules/es.array.concat.js");

require("core-js/modules/es.array.join.js");

var _child_process = require("child_process");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access
var isLoginShell = function isLoginShell(arg) {
  return arg && typeof arg.path === 'string' && Array.isArray(arg.args);
};
/**
 * Spawns and returns a Jest process with specific args
 *
 * @param {string[]} args
 * @returns {ChildProcess}
 */
// eslint-disable-next-line import/prefer-default-export


var createProcess = function createProcess(workspace, args) {
  var _workspace$nodeEnv;

  var runtimeExecutable = [workspace.jestCommandLine].concat(_toConsumableArray(args)); // If a path to configuration file was defined, push it to runtimeArgs

  if (workspace.pathToConfig) {
    runtimeExecutable.push('--config');
    runtimeExecutable.push(workspace.pathToConfig);
  }

  var env = _objectSpread(_objectSpread({}, process.env), (_workspace$nodeEnv = workspace.nodeEnv) !== null && _workspace$nodeEnv !== void 0 ? _workspace$nodeEnv : {});

  var cmd = runtimeExecutable.join(' ');

  var spawnCommandLine = function spawnCommandLine() {
    var spawnOptions = {
      cwd: workspace.rootPath,
      env: env,
      shell: typeof workspace.shell === 'string' && workspace.shell ? workspace.shell : true,
      // for non-windows: run in detached mode so the process will be the group leader and any subsequent process spawned
      // within can be later killed as a group to prevent orphan processes.
      // see https://nodejs.org/api/child_process.html#child_process_options_detached
      detached: process.platform !== 'win32'
    };

    if (workspace.debug) {
      // eslint-disable-next-line no-console
      console.log("spawning process with command=".concat(cmd), 'options:', spawnOptions);
    }

    return (0, _child_process.spawn)(cmd, [], spawnOptions);
  };

  var spawnLoginShell = function spawnLoginShell(shell) {
    var spawnOptions = {
      cwd: workspace.rootPath,
      env: env,
      detached: process.platform !== 'win32'
    };

    if (workspace.debug) {
      // eslint-disable-next-line no-console
      console.log("spawning login-shell \"".concat(shell.path, " ").concat(shell.args.join(' '), "\" for command=").concat(cmd), 'options:', spawnOptions);
    }

    var child = (0, _child_process.spawn)(shell.path, shell.args, spawnOptions);
    child.stdin.write("".concat(cmd, " \nexit $?\n"));
    return child;
  };

  if (isLoginShell(workspace.shell)) {
    if (process.platform === 'win32') {
      console.error('currently login-shell is only supported for non-windown platforms');
    } else {
      return spawnLoginShell(workspace.shell);
    }
  }

  return spawnCommandLine();
};

exports.createProcess = createProcess;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9Qcm9jZXNzLnRzIl0sIm5hbWVzIjpbImlzTG9naW5TaGVsbCIsImFyZyIsInBhdGgiLCJBcnJheSIsImlzQXJyYXkiLCJhcmdzIiwiY3JlYXRlUHJvY2VzcyIsIndvcmtzcGFjZSIsInJ1bnRpbWVFeGVjdXRhYmxlIiwiamVzdENvbW1hbmRMaW5lIiwicGF0aFRvQ29uZmlnIiwicHVzaCIsImVudiIsInByb2Nlc3MiLCJub2RlRW52IiwiY21kIiwiam9pbiIsInNwYXduQ29tbWFuZExpbmUiLCJzcGF3bk9wdGlvbnMiLCJjd2QiLCJyb290UGF0aCIsInNoZWxsIiwiZGV0YWNoZWQiLCJwbGF0Zm9ybSIsImRlYnVnIiwiY29uc29sZSIsImxvZyIsInNwYXduTG9naW5TaGVsbCIsImNoaWxkIiwic3RkaW4iLCJ3cml0ZSIsImVycm9yIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBUUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBR0E7QUFDQSxJQUFNQSxZQUFZLEdBQUcsU0FBZkEsWUFBZSxDQUFDQyxHQUFEO0FBQUEsU0FBaUNBLEdBQUcsSUFBSSxPQUFPQSxHQUFHLENBQUNDLElBQVgsS0FBb0IsUUFBM0IsSUFBdUNDLEtBQUssQ0FBQ0MsT0FBTixDQUFjSCxHQUFHLENBQUNJLElBQWxCLENBQXhFO0FBQUEsQ0FBckI7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ08sSUFBTUMsYUFBYSxHQUFHLFNBQWhCQSxhQUFnQixDQUFDQyxTQUFELEVBQThCRixJQUE5QixFQUErRDtBQUFBOztBQUMxRixNQUFNRyxpQkFBaUIsSUFBSUQsU0FBUyxDQUFDRSxlQUFkLDRCQUFrQ0osSUFBbEMsRUFBdkIsQ0FEMEYsQ0FHMUY7O0FBQ0EsTUFBSUUsU0FBUyxDQUFDRyxZQUFkLEVBQTRCO0FBQzFCRixJQUFBQSxpQkFBaUIsQ0FBQ0csSUFBbEIsQ0FBdUIsVUFBdkI7QUFDQUgsSUFBQUEsaUJBQWlCLENBQUNHLElBQWxCLENBQXVCSixTQUFTLENBQUNHLFlBQWpDO0FBQ0Q7O0FBRUQsTUFBTUUsR0FBRyxtQ0FBT0MsT0FBTyxDQUFDRCxHQUFmLHlCQUF3QkwsU0FBUyxDQUFDTyxPQUFsQyxtRUFBNkMsRUFBN0MsQ0FBVDs7QUFDQSxNQUFNQyxHQUFHLEdBQUdQLGlCQUFpQixDQUFDUSxJQUFsQixDQUF1QixHQUF2QixDQUFaOztBQUVBLE1BQU1DLGdCQUFnQixHQUFHLFNBQW5CQSxnQkFBbUIsR0FBTTtBQUM3QixRQUFNQyxZQUFZLEdBQUc7QUFDbkJDLE1BQUFBLEdBQUcsRUFBRVosU0FBUyxDQUFDYSxRQURJO0FBRW5CUixNQUFBQSxHQUFHLEVBQUhBLEdBRm1CO0FBR25CUyxNQUFBQSxLQUFLLEVBQUUsT0FBT2QsU0FBUyxDQUFDYyxLQUFqQixLQUEyQixRQUEzQixJQUF1Q2QsU0FBUyxDQUFDYyxLQUFqRCxHQUF5RGQsU0FBUyxDQUFDYyxLQUFuRSxHQUEyRSxJQUgvRDtBQUluQjtBQUNBO0FBQ0E7QUFDQUMsTUFBQUEsUUFBUSxFQUFFVCxPQUFPLENBQUNVLFFBQVIsS0FBcUI7QUFQWixLQUFyQjs7QUFVQSxRQUFJaEIsU0FBUyxDQUFDaUIsS0FBZCxFQUFxQjtBQUNuQjtBQUNBQyxNQUFBQSxPQUFPLENBQUNDLEdBQVIseUNBQTZDWCxHQUE3QyxHQUFvRCxVQUFwRCxFQUFnRUcsWUFBaEU7QUFDRDs7QUFFRCxXQUFPLDBCQUFNSCxHQUFOLEVBQVcsRUFBWCxFQUFlRyxZQUFmLENBQVA7QUFDRCxHQWpCRDs7QUFtQkEsTUFBTVMsZUFBZSxHQUFHLFNBQWxCQSxlQUFrQixDQUFDTixLQUFELEVBQXVCO0FBQzdDLFFBQU1ILFlBQVksR0FBRztBQUNuQkMsTUFBQUEsR0FBRyxFQUFFWixTQUFTLENBQUNhLFFBREk7QUFFbkJSLE1BQUFBLEdBQUcsRUFBSEEsR0FGbUI7QUFHbkJVLE1BQUFBLFFBQVEsRUFBRVQsT0FBTyxDQUFDVSxRQUFSLEtBQXFCO0FBSFosS0FBckI7O0FBTUEsUUFBSWhCLFNBQVMsQ0FBQ2lCLEtBQWQsRUFBcUI7QUFDbkI7QUFDQUMsTUFBQUEsT0FBTyxDQUFDQyxHQUFSLGtDQUMyQkwsS0FBSyxDQUFDbkIsSUFEakMsY0FDeUNtQixLQUFLLENBQUNoQixJQUFOLENBQVdXLElBQVgsQ0FBZ0IsR0FBaEIsQ0FEekMsNEJBQzhFRCxHQUQ5RSxHQUVFLFVBRkYsRUFHRUcsWUFIRjtBQUtEOztBQUVELFFBQU1VLEtBQUssR0FBRywwQkFBTVAsS0FBSyxDQUFDbkIsSUFBWixFQUFrQm1CLEtBQUssQ0FBQ2hCLElBQXhCLEVBQThCYSxZQUE5QixDQUFkO0FBQ0FVLElBQUFBLEtBQUssQ0FBQ0MsS0FBTixDQUFZQyxLQUFaLFdBQXFCZixHQUFyQjtBQUNBLFdBQU9hLEtBQVA7QUFDRCxHQW5CRDs7QUFxQkEsTUFBSTVCLFlBQVksQ0FBQ08sU0FBUyxDQUFDYyxLQUFYLENBQWhCLEVBQW1DO0FBQ2pDLFFBQUlSLE9BQU8sQ0FBQ1UsUUFBUixLQUFxQixPQUF6QixFQUFrQztBQUNoQ0UsTUFBQUEsT0FBTyxDQUFDTSxLQUFSLENBQWMsbUVBQWQ7QUFDRCxLQUZELE1BRU87QUFDTCxhQUFPSixlQUFlLENBQUNwQixTQUFTLENBQUNjLEtBQVgsQ0FBdEI7QUFDRDtBQUNGOztBQUNELFNBQU9KLGdCQUFnQixFQUF2QjtBQUNELENBNURNIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0IHtDaGlsZFByb2Nlc3MsIHNwYXdufSBmcm9tICdjaGlsZF9wcm9jZXNzJztcbmltcG9ydCBQcm9qZWN0V29ya3NwYWNlLCB7TG9naW5TaGVsbH0gZnJvbSAnLi9wcm9qZWN0X3dvcmtzcGFjZSc7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55LCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcbmNvbnN0IGlzTG9naW5TaGVsbCA9IChhcmc6IGFueSk6IGFyZyBpcyBMb2dpblNoZWxsID0+IGFyZyAmJiB0eXBlb2YgYXJnLnBhdGggPT09ICdzdHJpbmcnICYmIEFycmF5LmlzQXJyYXkoYXJnLmFyZ3MpO1xuXG4vKipcbiAqIFNwYXducyBhbmQgcmV0dXJucyBhIEplc3QgcHJvY2VzcyB3aXRoIHNwZWNpZmljIGFyZ3NcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBhcmdzXG4gKiBAcmV0dXJucyB7Q2hpbGRQcm9jZXNzfVxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L3ByZWZlci1kZWZhdWx0LWV4cG9ydFxuZXhwb3J0IGNvbnN0IGNyZWF0ZVByb2Nlc3MgPSAod29ya3NwYWNlOiBQcm9qZWN0V29ya3NwYWNlLCBhcmdzOiBzdHJpbmdbXSk6IENoaWxkUHJvY2VzcyA9PiB7XG4gIGNvbnN0IHJ1bnRpbWVFeGVjdXRhYmxlID0gW3dvcmtzcGFjZS5qZXN0Q29tbWFuZExpbmUsIC4uLmFyZ3NdO1xuXG4gIC8vIElmIGEgcGF0aCB0byBjb25maWd1cmF0aW9uIGZpbGUgd2FzIGRlZmluZWQsIHB1c2ggaXQgdG8gcnVudGltZUFyZ3NcbiAgaWYgKHdvcmtzcGFjZS5wYXRoVG9Db25maWcpIHtcbiAgICBydW50aW1lRXhlY3V0YWJsZS5wdXNoKCctLWNvbmZpZycpO1xuICAgIHJ1bnRpbWVFeGVjdXRhYmxlLnB1c2god29ya3NwYWNlLnBhdGhUb0NvbmZpZyk7XG4gIH1cblxuICBjb25zdCBlbnYgPSB7Li4ucHJvY2Vzcy5lbnYsIC4uLih3b3Jrc3BhY2Uubm9kZUVudiA/PyB7fSl9O1xuICBjb25zdCBjbWQgPSBydW50aW1lRXhlY3V0YWJsZS5qb2luKCcgJyk7XG5cbiAgY29uc3Qgc3Bhd25Db21tYW5kTGluZSA9ICgpID0+IHtcbiAgICBjb25zdCBzcGF3bk9wdGlvbnMgPSB7XG4gICAgICBjd2Q6IHdvcmtzcGFjZS5yb290UGF0aCxcbiAgICAgIGVudixcbiAgICAgIHNoZWxsOiB0eXBlb2Ygd29ya3NwYWNlLnNoZWxsID09PSAnc3RyaW5nJyAmJiB3b3Jrc3BhY2Uuc2hlbGwgPyB3b3Jrc3BhY2Uuc2hlbGwgOiB0cnVlLFxuICAgICAgLy8gZm9yIG5vbi13aW5kb3dzOiBydW4gaW4gZGV0YWNoZWQgbW9kZSBzbyB0aGUgcHJvY2VzcyB3aWxsIGJlIHRoZSBncm91cCBsZWFkZXIgYW5kIGFueSBzdWJzZXF1ZW50IHByb2Nlc3Mgc3Bhd25lZFxuICAgICAgLy8gd2l0aGluIGNhbiBiZSBsYXRlciBraWxsZWQgYXMgYSBncm91cCB0byBwcmV2ZW50IG9ycGhhbiBwcm9jZXNzZXMuXG4gICAgICAvLyBzZWUgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9jaGlsZF9wcm9jZXNzLmh0bWwjY2hpbGRfcHJvY2Vzc19vcHRpb25zX2RldGFjaGVkXG4gICAgICBkZXRhY2hlZDogcHJvY2Vzcy5wbGF0Zm9ybSAhPT0gJ3dpbjMyJyxcbiAgICB9O1xuXG4gICAgaWYgKHdvcmtzcGFjZS5kZWJ1Zykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUubG9nKGBzcGF3bmluZyBwcm9jZXNzIHdpdGggY29tbWFuZD0ke2NtZH1gLCAnb3B0aW9uczonLCBzcGF3bk9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiBzcGF3bihjbWQsIFtdLCBzcGF3bk9wdGlvbnMpO1xuICB9O1xuXG4gIGNvbnN0IHNwYXduTG9naW5TaGVsbCA9IChzaGVsbDogTG9naW5TaGVsbCkgPT4ge1xuICAgIGNvbnN0IHNwYXduT3B0aW9ucyA9IHtcbiAgICAgIGN3ZDogd29ya3NwYWNlLnJvb3RQYXRoLFxuICAgICAgZW52LFxuICAgICAgZGV0YWNoZWQ6IHByb2Nlc3MucGxhdGZvcm0gIT09ICd3aW4zMicsXG4gICAgfTtcblxuICAgIGlmICh3b3Jrc3BhY2UuZGVidWcpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgYHNwYXduaW5nIGxvZ2luLXNoZWxsIFwiJHtzaGVsbC5wYXRofSAke3NoZWxsLmFyZ3Muam9pbignICcpfVwiIGZvciBjb21tYW5kPSR7Y21kfWAsXG4gICAgICAgICdvcHRpb25zOicsXG4gICAgICAgIHNwYXduT3B0aW9uc1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBjaGlsZCA9IHNwYXduKHNoZWxsLnBhdGgsIHNoZWxsLmFyZ3MsIHNwYXduT3B0aW9ucyk7XG4gICAgY2hpbGQuc3RkaW4ud3JpdGUoYCR7Y21kfSBcXG5leGl0ICQ/XFxuYCk7XG4gICAgcmV0dXJuIGNoaWxkO1xuICB9O1xuXG4gIGlmIChpc0xvZ2luU2hlbGwod29ya3NwYWNlLnNoZWxsKSkge1xuICAgIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdjdXJyZW50bHkgbG9naW4tc2hlbGwgaXMgb25seSBzdXBwb3J0ZWQgZm9yIG5vbi13aW5kb3duIHBsYXRmb3JtcycpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3Bhd25Mb2dpblNoZWxsKHdvcmtzcGFjZS5zaGVsbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzcGF3bkNvbW1hbmRMaW5lKCk7XG59O1xuIl19